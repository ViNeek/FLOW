// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PRIME.proto

#ifndef PROTOBUF_PRIME_2eproto__INCLUDED
#define PROTOBUF_PRIME_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace PRIME {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PRIME_2eproto();
void protobuf_AssignDesc_PRIME_2eproto();
void protobuf_ShutdownFile_PRIME_2eproto();

class PRIMEMessage;
class PeerInfo;
class Reply;
class Reply_CSSIReply;
class Reply_PeerState;
class Reply_PRIMEState;
class Reply_P2PSIReply;
class Request;
class Request_CSSIRequest;
class Request_P2PSIRequest;
class Report;
class Report_DiffusionReport;
class Report_SwarmingReport;
class Report_AddDiffParentReport;
class Report_AddSwarmParentReport;
class Report_AddSwarmChildReport;

enum PRIMEMessage_MsgType {
  PRIMEMessage_MsgType_PRIME_REPLY = 1,
  PRIMEMessage_MsgType_PRIME_REQUEST = 2,
  PRIMEMessage_MsgType_PRIME_REPORT = 3,
  PRIMEMessage_MsgType_PRIME_HOLE_PUNCH = 4
};
bool PRIMEMessage_MsgType_IsValid(int value);
const PRIMEMessage_MsgType PRIMEMessage_MsgType_MsgType_MIN = PRIMEMessage_MsgType_PRIME_REPLY;
const PRIMEMessage_MsgType PRIMEMessage_MsgType_MsgType_MAX = PRIMEMessage_MsgType_PRIME_HOLE_PUNCH;
const int PRIMEMessage_MsgType_MsgType_ARRAYSIZE = PRIMEMessage_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PRIMEMessage_MsgType_descriptor();
inline const ::std::string& PRIMEMessage_MsgType_Name(PRIMEMessage_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PRIMEMessage_MsgType_descriptor(), value);
}
inline bool PRIMEMessage_MsgType_Parse(
    const ::std::string& name, PRIMEMessage_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PRIMEMessage_MsgType>(
    PRIMEMessage_MsgType_descriptor(), name, value);
}
enum Reply_ReplyType {
  Reply_ReplyType_NULL_TYPE = 1,
  Reply_ReplyType_CS_SESSION_INIT = 2,
  Reply_ReplyType_P2P_SESSION_INIT = 3,
  Reply_ReplyType_CS_SESSION_END = 4,
  Reply_ReplyType_P2P_SESSION_END = 5,
  Reply_ReplyType_SPEED_TEST = 6
};
bool Reply_ReplyType_IsValid(int value);
const Reply_ReplyType Reply_ReplyType_ReplyType_MIN = Reply_ReplyType_NULL_TYPE;
const Reply_ReplyType Reply_ReplyType_ReplyType_MAX = Reply_ReplyType_SPEED_TEST;
const int Reply_ReplyType_ReplyType_ARRAYSIZE = Reply_ReplyType_ReplyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ReplyType_descriptor();
inline const ::std::string& Reply_ReplyType_Name(Reply_ReplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ReplyType_descriptor(), value);
}
inline bool Reply_ReplyType_Parse(
    const ::std::string& name, Reply_ReplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ReplyType>(
    Reply_ReplyType_descriptor(), name, value);
}
enum Request_RequestType {
  Request_RequestType_NULL_TYPE = 1,
  Request_RequestType_CS_SESSION_INIT = 2,
  Request_RequestType_P2P_SESSION_INIT = 3,
  Request_RequestType_CS_SESSION_END = 4,
  Request_RequestType_P2P_SESSION_END = 5,
  Request_RequestType_SERVE_AS_SWARMING_PARENT = 6,
  Request_RequestType_BECOME_SWARMING_CHILD = 7,
  Request_RequestType_SERVE_AS_DIFFUSION_PARENT = 8,
  Request_RequestType_BECOME_DIFFUSION_CHILD = 9
};
bool Request_RequestType_IsValid(int value);
const Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_NULL_TYPE;
const Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_BECOME_DIFFUSION_CHILD;
const int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor();
inline const ::std::string& Request_RequestType_Name(Request_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RequestType_descriptor(), value);
}
inline bool Request_RequestType_Parse(
    const ::std::string& name, Request_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RequestType>(
    Request_RequestType_descriptor(), name, value);
}
enum Report_ReportType {
  Report_ReportType_NULL_TYPE = 1,
  Report_ReportType_SWARM_REPORT_TYPE = 2,
  Report_ReportType_DIFF_REPORT_TYPE = 3,
  Report_ReportType_ADD_DIFF_PARENT_TYPE = 4,
  Report_ReportType_ADD_DIFF_CHILD_TYPE = 5,
  Report_ReportType_ADD_SWARM_PARENT_TYPE = 6,
  Report_ReportType_ADD_SWARM_CHILD_TYPE = 7
};
bool Report_ReportType_IsValid(int value);
const Report_ReportType Report_ReportType_ReportType_MIN = Report_ReportType_NULL_TYPE;
const Report_ReportType Report_ReportType_ReportType_MAX = Report_ReportType_ADD_SWARM_CHILD_TYPE;
const int Report_ReportType_ReportType_ARRAYSIZE = Report_ReportType_ReportType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Report_ReportType_descriptor();
inline const ::std::string& Report_ReportType_Name(Report_ReportType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Report_ReportType_descriptor(), value);
}
inline bool Report_ReportType_Parse(
    const ::std::string& name, Report_ReportType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Report_ReportType>(
    Report_ReportType_descriptor(), name, value);
}
// ===================================================================

class PRIMEMessage : public ::google::protobuf::Message {
 public:
  PRIMEMessage();
  virtual ~PRIMEMessage();

  PRIMEMessage(const PRIMEMessage& from);

  inline PRIMEMessage& operator=(const PRIMEMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PRIMEMessage& default_instance();

  void Swap(PRIMEMessage* other);

  // implements Message ----------------------------------------------

  PRIMEMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PRIMEMessage& from);
  void MergeFrom(const PRIMEMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PRIMEMessage_MsgType MsgType;
  static const MsgType PRIME_REPLY = PRIMEMessage_MsgType_PRIME_REPLY;
  static const MsgType PRIME_REQUEST = PRIMEMessage_MsgType_PRIME_REQUEST;
  static const MsgType PRIME_REPORT = PRIMEMessage_MsgType_PRIME_REPORT;
  static const MsgType PRIME_HOLE_PUNCH = PRIMEMessage_MsgType_PRIME_HOLE_PUNCH;
  static inline bool MsgType_IsValid(int value) {
    return PRIMEMessage_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    PRIMEMessage_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    PRIMEMessage_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    PRIMEMessage_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return PRIMEMessage_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return PRIMEMessage_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return PRIMEMessage_MsgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PRIME.PRIMEMessage.MsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PRIME::PRIMEMessage_MsgType type() const;
  inline void set_type(::PRIME::PRIMEMessage_MsgType value);

  // optional .PRIME.Reply reply = 2;
  inline bool has_reply() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 2;
  inline const ::PRIME::Reply& reply() const;
  inline ::PRIME::Reply* mutable_reply();
  inline ::PRIME::Reply* release_reply();
  inline void set_allocated_reply(::PRIME::Reply* reply);

  // optional .PRIME.Request request = 3;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 3;
  inline const ::PRIME::Request& request() const;
  inline ::PRIME::Request* mutable_request();
  inline ::PRIME::Request* release_request();
  inline void set_allocated_request(::PRIME::Request* request);

  // optional .PRIME.Report report = 4;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 4;
  inline const ::PRIME::Report& report() const;
  inline ::PRIME::Report* mutable_report();
  inline ::PRIME::Report* release_report();
  inline void set_allocated_report(::PRIME::Report* report);

  // optional string dummy = 5;
  inline bool has_dummy() const;
  inline void clear_dummy();
  static const int kDummyFieldNumber = 5;
  inline const ::std::string& dummy() const;
  inline void set_dummy(const ::std::string& value);
  inline void set_dummy(const char* value);
  inline void set_dummy(const char* value, size_t size);
  inline ::std::string* mutable_dummy();
  inline ::std::string* release_dummy();
  inline void set_allocated_dummy(::std::string* dummy);

  // @@protoc_insertion_point(class_scope:PRIME.PRIMEMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reply();
  inline void clear_has_reply();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_report();
  inline void clear_has_report();
  inline void set_has_dummy();
  inline void clear_has_dummy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::Reply* reply_;
  ::PRIME::Request* request_;
  ::PRIME::Report* report_;
  ::std::string* dummy_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static PRIMEMessage* default_instance_;
};
// -------------------------------------------------------------------

class PeerInfo : public ::google::protobuf::Message {
 public:
  PeerInfo();
  virtual ~PeerInfo();

  PeerInfo(const PeerInfo& from);

  inline PeerInfo& operator=(const PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerInfo& default_instance();

  void Swap(PeerInfo* other);

  // implements Message ----------------------------------------------

  PeerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerInfo& from);
  void MergeFrom(const PeerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipAddr = 1;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 1;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // required int32 repPort = 2;
  inline bool has_repport() const;
  inline void clear_repport();
  static const int kRepPortFieldNumber = 2;
  inline ::google::protobuf::int32 repport() const;
  inline void set_repport(::google::protobuf::int32 value);

  // required int32 rtpPort = 3;
  inline bool has_rtpport() const;
  inline void clear_rtpport();
  static const int kRtpPortFieldNumber = 3;
  inline ::google::protobuf::int32 rtpport() const;
  inline void set_rtpport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PRIME.PeerInfo)
 private:
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();
  inline void set_has_repport();
  inline void clear_has_repport();
  inline void set_has_rtpport();
  inline void clear_has_rtpport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ipaddr_;
  ::google::protobuf::int32 repport_;
  ::google::protobuf::int32 rtpport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static PeerInfo* default_instance_;
};
// -------------------------------------------------------------------

class Reply_CSSIReply : public ::google::protobuf::Message {
 public:
  Reply_CSSIReply();
  virtual ~Reply_CSSIReply();

  Reply_CSSIReply(const Reply_CSSIReply& from);

  inline Reply_CSSIReply& operator=(const Reply_CSSIReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_CSSIReply& default_instance();

  void Swap(Reply_CSSIReply* other);

  // implements Message ----------------------------------------------

  Reply_CSSIReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_CSSIReply& from);
  void MergeFrom(const Reply_CSSIReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 streamPort = 1;
  inline bool has_streamport() const;
  inline void clear_streamport();
  static const int kStreamPortFieldNumber = 1;
  inline ::google::protobuf::int32 streamport() const;
  inline void set_streamport(::google::protobuf::int32 value);

  // required string sdp = 2;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 2;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // required int32 maxFrameCount = 3;
  inline bool has_maxframecount() const;
  inline void clear_maxframecount();
  static const int kMaxFrameCountFieldNumber = 3;
  inline ::google::protobuf::int32 maxframecount() const;
  inline void set_maxframecount(::google::protobuf::int32 value);

  // required int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int32 pixFmt = 6;
  inline bool has_pixfmt() const;
  inline void clear_pixfmt();
  static const int kPixFmtFieldNumber = 6;
  inline ::google::protobuf::int32 pixfmt() const;
  inline void set_pixfmt(::google::protobuf::int32 value);

  // required .PRIME.PeerInfo diffParent = 7;
  inline bool has_diffparent() const;
  inline void clear_diffparent();
  static const int kDiffParentFieldNumber = 7;
  inline const ::PRIME::PeerInfo& diffparent() const;
  inline ::PRIME::PeerInfo* mutable_diffparent();
  inline ::PRIME::PeerInfo* release_diffparent();
  inline void set_allocated_diffparent(::PRIME::PeerInfo* diffparent);

  // @@protoc_insertion_point(class_scope:PRIME.Reply.CSSIReply)
 private:
  inline void set_has_streamport();
  inline void clear_has_streamport();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_maxframecount();
  inline void clear_has_maxframecount();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_pixfmt();
  inline void clear_has_pixfmt();
  inline void set_has_diffparent();
  inline void clear_has_diffparent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sdp_;
  ::google::protobuf::int32 streamport_;
  ::google::protobuf::int32 maxframecount_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::PRIME::PeerInfo* diffparent_;
  ::google::protobuf::int32 pixfmt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Reply_CSSIReply* default_instance_;
};
// -------------------------------------------------------------------

class Reply_PeerState : public ::google::protobuf::Message {
 public:
  Reply_PeerState();
  virtual ~Reply_PeerState();

  Reply_PeerState(const Reply_PeerState& from);

  inline Reply_PeerState& operator=(const Reply_PeerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_PeerState& default_instance();

  void Swap(Reply_PeerState* other);

  // implements Message ----------------------------------------------

  Reply_PeerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_PeerState& from);
  void MergeFrom(const Reply_PeerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PRIME.PeerInfo dest = 1;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 1;
  inline const ::PRIME::PeerInfo& dest() const;
  inline ::PRIME::PeerInfo* mutable_dest();
  inline ::PRIME::PeerInfo* release_dest();
  inline void set_allocated_dest(::PRIME::PeerInfo* dest);

  // repeated .PRIME.PeerInfo diffParents = 2;
  inline int diffparents_size() const;
  inline void clear_diffparents();
  static const int kDiffParentsFieldNumber = 2;
  inline const ::PRIME::PeerInfo& diffparents(int index) const;
  inline ::PRIME::PeerInfo* mutable_diffparents(int index);
  inline ::PRIME::PeerInfo* add_diffparents();
  inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
      diffparents() const;
  inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
      mutable_diffparents();

  // repeated .PRIME.PeerInfo diffChildren = 3;
  inline int diffchildren_size() const;
  inline void clear_diffchildren();
  static const int kDiffChildrenFieldNumber = 3;
  inline const ::PRIME::PeerInfo& diffchildren(int index) const;
  inline ::PRIME::PeerInfo* mutable_diffchildren(int index);
  inline ::PRIME::PeerInfo* add_diffchildren();
  inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
      diffchildren() const;
  inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
      mutable_diffchildren();

  // repeated .PRIME.PeerInfo swarmParents = 4;
  inline int swarmparents_size() const;
  inline void clear_swarmparents();
  static const int kSwarmParentsFieldNumber = 4;
  inline const ::PRIME::PeerInfo& swarmparents(int index) const;
  inline ::PRIME::PeerInfo* mutable_swarmparents(int index);
  inline ::PRIME::PeerInfo* add_swarmparents();
  inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
      swarmparents() const;
  inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
      mutable_swarmparents();

  // repeated .PRIME.PeerInfo swarmChildren = 5;
  inline int swarmchildren_size() const;
  inline void clear_swarmchildren();
  static const int kSwarmChildrenFieldNumber = 5;
  inline const ::PRIME::PeerInfo& swarmchildren(int index) const;
  inline ::PRIME::PeerInfo* mutable_swarmchildren(int index);
  inline ::PRIME::PeerInfo* add_swarmchildren();
  inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
      swarmchildren() const;
  inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
      mutable_swarmchildren();

  // @@protoc_insertion_point(class_scope:PRIME.Reply.PeerState)
 private:
  inline void set_has_dest();
  inline void clear_has_dest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::PeerInfo* dest_;
  ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo > diffparents_;
  ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo > diffchildren_;
  ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo > swarmparents_;
  ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo > swarmchildren_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Reply_PeerState* default_instance_;
};
// -------------------------------------------------------------------

class Reply_PRIMEState : public ::google::protobuf::Message {
 public:
  Reply_PRIMEState();
  virtual ~Reply_PRIMEState();

  Reply_PRIMEState(const Reply_PRIMEState& from);

  inline Reply_PRIMEState& operator=(const Reply_PRIMEState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_PRIMEState& default_instance();

  void Swap(Reply_PRIMEState* other);

  // implements Message ----------------------------------------------

  Reply_PRIMEState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_PRIMEState& from);
  void MergeFrom(const Reply_PRIMEState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PRIME.Reply.PeerState nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::PRIME::Reply_PeerState& nodes(int index) const;
  inline ::PRIME::Reply_PeerState* mutable_nodes(int index);
  inline ::PRIME::Reply_PeerState* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::PRIME::Reply_PeerState >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::PRIME::Reply_PeerState >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:PRIME.Reply.PRIMEState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PRIME::Reply_PeerState > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Reply_PRIMEState* default_instance_;
};
// -------------------------------------------------------------------

class Reply_P2PSIReply : public ::google::protobuf::Message {
 public:
  Reply_P2PSIReply();
  virtual ~Reply_P2PSIReply();

  Reply_P2PSIReply(const Reply_P2PSIReply& from);

  inline Reply_P2PSIReply& operator=(const Reply_P2PSIReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_P2PSIReply& default_instance();

  void Swap(Reply_P2PSIReply* other);

  // implements Message ----------------------------------------------

  Reply_P2PSIReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_P2PSIReply& from);
  void MergeFrom(const Reply_P2PSIReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 streamPort = 1;
  inline bool has_streamport() const;
  inline void clear_streamport();
  static const int kStreamPortFieldNumber = 1;
  inline ::google::protobuf::int32 streamport() const;
  inline void set_streamport(::google::protobuf::int32 value);

  // required string sdp = 2;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 2;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // required int32 maxFrameCount = 3;
  inline bool has_maxframecount() const;
  inline void clear_maxframecount();
  static const int kMaxFrameCountFieldNumber = 3;
  inline ::google::protobuf::int32 maxframecount() const;
  inline void set_maxframecount(::google::protobuf::int32 value);

  // required int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int32 pixFmt = 6;
  inline bool has_pixfmt() const;
  inline void clear_pixfmt();
  static const int kPixFmtFieldNumber = 6;
  inline ::google::protobuf::int32 pixfmt() const;
  inline void set_pixfmt(::google::protobuf::int32 value);

  // required .PRIME.PeerInfo diffParent = 7;
  inline bool has_diffparent() const;
  inline void clear_diffparent();
  static const int kDiffParentFieldNumber = 7;
  inline const ::PRIME::PeerInfo& diffparent() const;
  inline ::PRIME::PeerInfo* mutable_diffparent();
  inline ::PRIME::PeerInfo* release_diffparent();
  inline void set_allocated_diffparent(::PRIME::PeerInfo* diffparent);

  // @@protoc_insertion_point(class_scope:PRIME.Reply.P2PSIReply)
 private:
  inline void set_has_streamport();
  inline void clear_has_streamport();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_maxframecount();
  inline void clear_has_maxframecount();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_pixfmt();
  inline void clear_has_pixfmt();
  inline void set_has_diffparent();
  inline void clear_has_diffparent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sdp_;
  ::google::protobuf::int32 streamport_;
  ::google::protobuf::int32 maxframecount_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::PRIME::PeerInfo* diffparent_;
  ::google::protobuf::int32 pixfmt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Reply_P2PSIReply* default_instance_;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  Reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_CSSIReply CSSIReply;
  typedef Reply_PeerState PeerState;
  typedef Reply_PRIMEState PRIMEState;
  typedef Reply_P2PSIReply P2PSIReply;

  typedef Reply_ReplyType ReplyType;
  static const ReplyType NULL_TYPE = Reply_ReplyType_NULL_TYPE;
  static const ReplyType CS_SESSION_INIT = Reply_ReplyType_CS_SESSION_INIT;
  static const ReplyType P2P_SESSION_INIT = Reply_ReplyType_P2P_SESSION_INIT;
  static const ReplyType CS_SESSION_END = Reply_ReplyType_CS_SESSION_END;
  static const ReplyType P2P_SESSION_END = Reply_ReplyType_P2P_SESSION_END;
  static const ReplyType SPEED_TEST = Reply_ReplyType_SPEED_TEST;
  static inline bool ReplyType_IsValid(int value) {
    return Reply_ReplyType_IsValid(value);
  }
  static const ReplyType ReplyType_MIN =
    Reply_ReplyType_ReplyType_MIN;
  static const ReplyType ReplyType_MAX =
    Reply_ReplyType_ReplyType_MAX;
  static const int ReplyType_ARRAYSIZE =
    Reply_ReplyType_ReplyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReplyType_descriptor() {
    return Reply_ReplyType_descriptor();
  }
  static inline const ::std::string& ReplyType_Name(ReplyType value) {
    return Reply_ReplyType_Name(value);
  }
  static inline bool ReplyType_Parse(const ::std::string& name,
      ReplyType* value) {
    return Reply_ReplyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PRIME.Reply.ReplyType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PRIME::Reply_ReplyType type() const;
  inline void set_type(::PRIME::Reply_ReplyType value);

  // optional .PRIME.Reply.CSSIReply cs_session_state = 21;
  inline bool has_cs_session_state() const;
  inline void clear_cs_session_state();
  static const int kCsSessionStateFieldNumber = 21;
  inline const ::PRIME::Reply_CSSIReply& cs_session_state() const;
  inline ::PRIME::Reply_CSSIReply* mutable_cs_session_state();
  inline ::PRIME::Reply_CSSIReply* release_cs_session_state();
  inline void set_allocated_cs_session_state(::PRIME::Reply_CSSIReply* cs_session_state);

  // optional .PRIME.Reply.P2PSIReply p2p_session_state = 22;
  inline bool has_p2p_session_state() const;
  inline void clear_p2p_session_state();
  static const int kP2PSessionStateFieldNumber = 22;
  inline const ::PRIME::Reply_P2PSIReply& p2p_session_state() const;
  inline ::PRIME::Reply_P2PSIReply* mutable_p2p_session_state();
  inline ::PRIME::Reply_P2PSIReply* release_p2p_session_state();
  inline void set_allocated_p2p_session_state(::PRIME::Reply_P2PSIReply* p2p_session_state);

  // @@protoc_insertion_point(class_scope:PRIME.Reply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cs_session_state();
  inline void clear_has_cs_session_state();
  inline void set_has_p2p_session_state();
  inline void clear_has_p2p_session_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::Reply_CSSIReply* cs_session_state_;
  ::PRIME::Reply_P2PSIReply* p2p_session_state_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Reply* default_instance_;
};
// -------------------------------------------------------------------

class Request_CSSIRequest : public ::google::protobuf::Message {
 public:
  Request_CSSIRequest();
  virtual ~Request_CSSIRequest();

  Request_CSSIRequest(const Request_CSSIRequest& from);

  inline Request_CSSIRequest& operator=(const Request_CSSIRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_CSSIRequest& default_instance();

  void Swap(Request_CSSIRequest* other);

  // implements Message ----------------------------------------------

  Request_CSSIRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_CSSIRequest& from);
  void MergeFrom(const Request_CSSIRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double DBW = 1;
  inline bool has_dbw() const;
  inline void clear_dbw();
  static const int kDBWFieldNumber = 1;
  inline double dbw() const;
  inline void set_dbw(double value);

  // required string peerName = 2;
  inline bool has_peername() const;
  inline void clear_peername();
  static const int kPeerNameFieldNumber = 2;
  inline const ::std::string& peername() const;
  inline void set_peername(const ::std::string& value);
  inline void set_peername(const char* value);
  inline void set_peername(const char* value, size_t size);
  inline ::std::string* mutable_peername();
  inline ::std::string* release_peername();
  inline void set_allocated_peername(::std::string* peername);

  // required int32 repPort = 3;
  inline bool has_repport() const;
  inline void clear_repport();
  static const int kRepPortFieldNumber = 3;
  inline ::google::protobuf::int32 repport() const;
  inline void set_repport(::google::protobuf::int32 value);

  // required string ipAddr = 4;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 4;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // @@protoc_insertion_point(class_scope:PRIME.Request.CSSIRequest)
 private:
  inline void set_has_dbw();
  inline void clear_has_dbw();
  inline void set_has_peername();
  inline void clear_has_peername();
  inline void set_has_repport();
  inline void clear_has_repport();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double dbw_;
  ::std::string* peername_;
  ::std::string* ipaddr_;
  ::google::protobuf::int32 repport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Request_CSSIRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request_P2PSIRequest : public ::google::protobuf::Message {
 public:
  Request_P2PSIRequest();
  virtual ~Request_P2PSIRequest();

  Request_P2PSIRequest(const Request_P2PSIRequest& from);

  inline Request_P2PSIRequest& operator=(const Request_P2PSIRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_P2PSIRequest& default_instance();

  void Swap(Request_P2PSIRequest* other);

  // implements Message ----------------------------------------------

  Request_P2PSIRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_P2PSIRequest& from);
  void MergeFrom(const Request_P2PSIRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double DBW = 1;
  inline bool has_dbw() const;
  inline void clear_dbw();
  static const int kDBWFieldNumber = 1;
  inline double dbw() const;
  inline void set_dbw(double value);

  // required double UBW = 2;
  inline bool has_ubw() const;
  inline void clear_ubw();
  static const int kUBWFieldNumber = 2;
  inline double ubw() const;
  inline void set_ubw(double value);

  // required int32 repPort = 3;
  inline bool has_repport() const;
  inline void clear_repport();
  static const int kRepPortFieldNumber = 3;
  inline ::google::protobuf::int32 repport() const;
  inline void set_repport(::google::protobuf::int32 value);

  // required int32 rtpRecvPort = 4;
  inline bool has_rtprecvport() const;
  inline void clear_rtprecvport();
  static const int kRtpRecvPortFieldNumber = 4;
  inline ::google::protobuf::int32 rtprecvport() const;
  inline void set_rtprecvport(::google::protobuf::int32 value);

  // required int32 repSendPort = 5;
  inline bool has_repsendport() const;
  inline void clear_repsendport();
  static const int kRepSendPortFieldNumber = 5;
  inline ::google::protobuf::int32 repsendport() const;
  inline void set_repsendport(::google::protobuf::int32 value);

  // required string peerName = 6;
  inline bool has_peername() const;
  inline void clear_peername();
  static const int kPeerNameFieldNumber = 6;
  inline const ::std::string& peername() const;
  inline void set_peername(const ::std::string& value);
  inline void set_peername(const char* value);
  inline void set_peername(const char* value, size_t size);
  inline ::std::string* mutable_peername();
  inline ::std::string* release_peername();
  inline void set_allocated_peername(::std::string* peername);

  // required string ipAddr = 7;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpAddrFieldNumber = 7;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // @@protoc_insertion_point(class_scope:PRIME.Request.P2PSIRequest)
 private:
  inline void set_has_dbw();
  inline void clear_has_dbw();
  inline void set_has_ubw();
  inline void clear_has_ubw();
  inline void set_has_repport();
  inline void clear_has_repport();
  inline void set_has_rtprecvport();
  inline void clear_has_rtprecvport();
  inline void set_has_repsendport();
  inline void clear_has_repsendport();
  inline void set_has_peername();
  inline void clear_has_peername();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double dbw_;
  double ubw_;
  ::google::protobuf::int32 repport_;
  ::google::protobuf::int32 rtprecvport_;
  ::std::string* peername_;
  ::std::string* ipaddr_;
  ::google::protobuf::int32 repsendport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Request_P2PSIRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_CSSIRequest CSSIRequest;
  typedef Request_P2PSIRequest P2PSIRequest;

  typedef Request_RequestType RequestType;
  static const RequestType NULL_TYPE = Request_RequestType_NULL_TYPE;
  static const RequestType CS_SESSION_INIT = Request_RequestType_CS_SESSION_INIT;
  static const RequestType P2P_SESSION_INIT = Request_RequestType_P2P_SESSION_INIT;
  static const RequestType CS_SESSION_END = Request_RequestType_CS_SESSION_END;
  static const RequestType P2P_SESSION_END = Request_RequestType_P2P_SESSION_END;
  static const RequestType SERVE_AS_SWARMING_PARENT = Request_RequestType_SERVE_AS_SWARMING_PARENT;
  static const RequestType BECOME_SWARMING_CHILD = Request_RequestType_BECOME_SWARMING_CHILD;
  static const RequestType SERVE_AS_DIFFUSION_PARENT = Request_RequestType_SERVE_AS_DIFFUSION_PARENT;
  static const RequestType BECOME_DIFFUSION_CHILD = Request_RequestType_BECOME_DIFFUSION_CHILD;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return Request_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return Request_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return Request_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PRIME.Request.RequestType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PRIME::Request_RequestType type() const;
  inline void set_type(::PRIME::Request_RequestType value);

  // optional .PRIME.Request.CSSIRequest cs_session_props = 21;
  inline bool has_cs_session_props() const;
  inline void clear_cs_session_props();
  static const int kCsSessionPropsFieldNumber = 21;
  inline const ::PRIME::Request_CSSIRequest& cs_session_props() const;
  inline ::PRIME::Request_CSSIRequest* mutable_cs_session_props();
  inline ::PRIME::Request_CSSIRequest* release_cs_session_props();
  inline void set_allocated_cs_session_props(::PRIME::Request_CSSIRequest* cs_session_props);

  // optional .PRIME.Request.P2PSIRequest p2p_session_props = 22;
  inline bool has_p2p_session_props() const;
  inline void clear_p2p_session_props();
  static const int kP2PSessionPropsFieldNumber = 22;
  inline const ::PRIME::Request_P2PSIRequest& p2p_session_props() const;
  inline ::PRIME::Request_P2PSIRequest* mutable_p2p_session_props();
  inline ::PRIME::Request_P2PSIRequest* release_p2p_session_props();
  inline void set_allocated_p2p_session_props(::PRIME::Request_P2PSIRequest* p2p_session_props);

  // @@protoc_insertion_point(class_scope:PRIME.Request)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cs_session_props();
  inline void clear_has_cs_session_props();
  inline void set_has_p2p_session_props();
  inline void clear_has_p2p_session_props();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::Request_CSSIRequest* cs_session_props_;
  ::PRIME::Request_P2PSIRequest* p2p_session_props_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Report_DiffusionReport : public ::google::protobuf::Message {
 public:
  Report_DiffusionReport();
  virtual ~Report_DiffusionReport();

  Report_DiffusionReport(const Report_DiffusionReport& from);

  inline Report_DiffusionReport& operator=(const Report_DiffusionReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report_DiffusionReport& default_instance();

  void Swap(Report_DiffusionReport* other);

  // implements Message ----------------------------------------------

  Report_DiffusionReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report_DiffusionReport& from);
  void MergeFrom(const Report_DiffusionReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 start_ts = 1;
  inline bool has_start_ts() const;
  inline void clear_start_ts();
  static const int kStartTsFieldNumber = 1;
  inline ::google::protobuf::uint64 start_ts() const;
  inline void set_start_ts(::google::protobuf::uint64 value);

  // required uint64 end_ts = 2;
  inline bool has_end_ts() const;
  inline void clear_end_ts();
  static const int kEndTsFieldNumber = 2;
  inline ::google::protobuf::uint64 end_ts() const;
  inline void set_end_ts(::google::protobuf::uint64 value);

  // required uint32 start_seq = 3;
  inline bool has_start_seq() const;
  inline void clear_start_seq();
  static const int kStartSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 start_seq() const;
  inline void set_start_seq(::google::protobuf::uint32 value);

  // required uint32 end_seq = 4;
  inline bool has_end_seq() const;
  inline void clear_end_seq();
  static const int kEndSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 end_seq() const;
  inline void set_end_seq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PRIME.Report.DiffusionReport)
 private:
  inline void set_has_start_ts();
  inline void clear_has_start_ts();
  inline void set_has_end_ts();
  inline void clear_has_end_ts();
  inline void set_has_start_seq();
  inline void clear_has_start_seq();
  inline void set_has_end_seq();
  inline void clear_has_end_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 start_ts_;
  ::google::protobuf::uint64 end_ts_;
  ::google::protobuf::uint32 start_seq_;
  ::google::protobuf::uint32 end_seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report_DiffusionReport* default_instance_;
};
// -------------------------------------------------------------------

class Report_SwarmingReport : public ::google::protobuf::Message {
 public:
  Report_SwarmingReport();
  virtual ~Report_SwarmingReport();

  Report_SwarmingReport(const Report_SwarmingReport& from);

  inline Report_SwarmingReport& operator=(const Report_SwarmingReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report_SwarmingReport& default_instance();

  void Swap(Report_SwarmingReport* other);

  // implements Message ----------------------------------------------

  Report_SwarmingReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report_SwarmingReport& from);
  void MergeFrom(const Report_SwarmingReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 start_seq = 1;
  inline bool has_start_seq() const;
  inline void clear_start_seq();
  static const int kStartSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 start_seq() const;
  inline void set_start_seq(::google::protobuf::uint32 value);

  // required uint32 end_seq = 2;
  inline bool has_end_seq() const;
  inline void clear_end_seq();
  static const int kEndSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 end_seq() const;
  inline void set_end_seq(::google::protobuf::uint32 value);

  // repeated bool state = 3;
  inline int state_size() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline bool state(int index) const;
  inline void set_state(int index, bool value);
  inline void add_state(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      state() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_state();

  // @@protoc_insertion_point(class_scope:PRIME.Report.SwarmingReport)
 private:
  inline void set_has_start_seq();
  inline void clear_has_start_seq();
  inline void set_has_end_seq();
  inline void clear_has_end_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_seq_;
  ::google::protobuf::uint32 end_seq_;
  ::google::protobuf::RepeatedField< bool > state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report_SwarmingReport* default_instance_;
};
// -------------------------------------------------------------------

class Report_AddDiffParentReport : public ::google::protobuf::Message {
 public:
  Report_AddDiffParentReport();
  virtual ~Report_AddDiffParentReport();

  Report_AddDiffParentReport(const Report_AddDiffParentReport& from);

  inline Report_AddDiffParentReport& operator=(const Report_AddDiffParentReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report_AddDiffParentReport& default_instance();

  void Swap(Report_AddDiffParentReport* other);

  // implements Message ----------------------------------------------

  Report_AddDiffParentReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report_AddDiffParentReport& from);
  void MergeFrom(const Report_AddDiffParentReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string peerName = 1;
  inline bool has_peername() const;
  inline void clear_peername();
  static const int kPeerNameFieldNumber = 1;
  inline const ::std::string& peername() const;
  inline void set_peername(const ::std::string& value);
  inline void set_peername(const char* value);
  inline void set_peername(const char* value, size_t size);
  inline ::std::string* mutable_peername();
  inline ::std::string* release_peername();
  inline void set_allocated_peername(::std::string* peername);

  // required int32 stream_port = 2;
  inline bool has_stream_port() const;
  inline void clear_stream_port();
  static const int kStreamPortFieldNumber = 2;
  inline ::google::protobuf::int32 stream_port() const;
  inline void set_stream_port(::google::protobuf::int32 value);

  // required int32 rep_port = 3;
  inline bool has_rep_port() const;
  inline void clear_rep_port();
  static const int kRepPortFieldNumber = 3;
  inline ::google::protobuf::int32 rep_port() const;
  inline void set_rep_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PRIME.Report.AddDiffParentReport)
 private:
  inline void set_has_peername();
  inline void clear_has_peername();
  inline void set_has_stream_port();
  inline void clear_has_stream_port();
  inline void set_has_rep_port();
  inline void clear_has_rep_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* peername_;
  ::google::protobuf::int32 stream_port_;
  ::google::protobuf::int32 rep_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report_AddDiffParentReport* default_instance_;
};
// -------------------------------------------------------------------

class Report_AddSwarmParentReport : public ::google::protobuf::Message {
 public:
  Report_AddSwarmParentReport();
  virtual ~Report_AddSwarmParentReport();

  Report_AddSwarmParentReport(const Report_AddSwarmParentReport& from);

  inline Report_AddSwarmParentReport& operator=(const Report_AddSwarmParentReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report_AddSwarmParentReport& default_instance();

  void Swap(Report_AddSwarmParentReport* other);

  // implements Message ----------------------------------------------

  Report_AddSwarmParentReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report_AddSwarmParentReport& from);
  void MergeFrom(const Report_AddSwarmParentReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PRIME.PeerInfo swarmParent = 1;
  inline bool has_swarmparent() const;
  inline void clear_swarmparent();
  static const int kSwarmParentFieldNumber = 1;
  inline const ::PRIME::PeerInfo& swarmparent() const;
  inline ::PRIME::PeerInfo* mutable_swarmparent();
  inline ::PRIME::PeerInfo* release_swarmparent();
  inline void set_allocated_swarmparent(::PRIME::PeerInfo* swarmparent);

  // @@protoc_insertion_point(class_scope:PRIME.Report.AddSwarmParentReport)
 private:
  inline void set_has_swarmparent();
  inline void clear_has_swarmparent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::PeerInfo* swarmparent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report_AddSwarmParentReport* default_instance_;
};
// -------------------------------------------------------------------

class Report_AddSwarmChildReport : public ::google::protobuf::Message {
 public:
  Report_AddSwarmChildReport();
  virtual ~Report_AddSwarmChildReport();

  Report_AddSwarmChildReport(const Report_AddSwarmChildReport& from);

  inline Report_AddSwarmChildReport& operator=(const Report_AddSwarmChildReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report_AddSwarmChildReport& default_instance();

  void Swap(Report_AddSwarmChildReport* other);

  // implements Message ----------------------------------------------

  Report_AddSwarmChildReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report_AddSwarmChildReport& from);
  void MergeFrom(const Report_AddSwarmChildReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PRIME.PeerInfo swarmChild = 1;
  inline bool has_swarmchild() const;
  inline void clear_swarmchild();
  static const int kSwarmChildFieldNumber = 1;
  inline const ::PRIME::PeerInfo& swarmchild() const;
  inline ::PRIME::PeerInfo* mutable_swarmchild();
  inline ::PRIME::PeerInfo* release_swarmchild();
  inline void set_allocated_swarmchild(::PRIME::PeerInfo* swarmchild);

  // @@protoc_insertion_point(class_scope:PRIME.Report.AddSwarmChildReport)
 private:
  inline void set_has_swarmchild();
  inline void clear_has_swarmchild();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::PeerInfo* swarmchild_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report_AddSwarmChildReport* default_instance_;
};
// -------------------------------------------------------------------

class Report : public ::google::protobuf::Message {
 public:
  Report();
  virtual ~Report();

  Report(const Report& from);

  inline Report& operator=(const Report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Report& default_instance();

  void Swap(Report* other);

  // implements Message ----------------------------------------------

  Report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Report& from);
  void MergeFrom(const Report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Report_DiffusionReport DiffusionReport;
  typedef Report_SwarmingReport SwarmingReport;
  typedef Report_AddDiffParentReport AddDiffParentReport;
  typedef Report_AddSwarmParentReport AddSwarmParentReport;
  typedef Report_AddSwarmChildReport AddSwarmChildReport;

  typedef Report_ReportType ReportType;
  static const ReportType NULL_TYPE = Report_ReportType_NULL_TYPE;
  static const ReportType SWARM_REPORT_TYPE = Report_ReportType_SWARM_REPORT_TYPE;
  static const ReportType DIFF_REPORT_TYPE = Report_ReportType_DIFF_REPORT_TYPE;
  static const ReportType ADD_DIFF_PARENT_TYPE = Report_ReportType_ADD_DIFF_PARENT_TYPE;
  static const ReportType ADD_DIFF_CHILD_TYPE = Report_ReportType_ADD_DIFF_CHILD_TYPE;
  static const ReportType ADD_SWARM_PARENT_TYPE = Report_ReportType_ADD_SWARM_PARENT_TYPE;
  static const ReportType ADD_SWARM_CHILD_TYPE = Report_ReportType_ADD_SWARM_CHILD_TYPE;
  static inline bool ReportType_IsValid(int value) {
    return Report_ReportType_IsValid(value);
  }
  static const ReportType ReportType_MIN =
    Report_ReportType_ReportType_MIN;
  static const ReportType ReportType_MAX =
    Report_ReportType_ReportType_MAX;
  static const int ReportType_ARRAYSIZE =
    Report_ReportType_ReportType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReportType_descriptor() {
    return Report_ReportType_descriptor();
  }
  static inline const ::std::string& ReportType_Name(ReportType value) {
    return Report_ReportType_Name(value);
  }
  static inline bool ReportType_Parse(const ::std::string& name,
      ReportType* value) {
    return Report_ReportType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PRIME.Report.ReportType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PRIME::Report_ReportType type() const;
  inline void set_type(::PRIME::Report_ReportType value);

  // optional .PRIME.Report.DiffusionReport diff_report = 21;
  inline bool has_diff_report() const;
  inline void clear_diff_report();
  static const int kDiffReportFieldNumber = 21;
  inline const ::PRIME::Report_DiffusionReport& diff_report() const;
  inline ::PRIME::Report_DiffusionReport* mutable_diff_report();
  inline ::PRIME::Report_DiffusionReport* release_diff_report();
  inline void set_allocated_diff_report(::PRIME::Report_DiffusionReport* diff_report);

  // optional .PRIME.Report.SwarmingReport swarm_report = 22;
  inline bool has_swarm_report() const;
  inline void clear_swarm_report();
  static const int kSwarmReportFieldNumber = 22;
  inline const ::PRIME::Report_SwarmingReport& swarm_report() const;
  inline ::PRIME::Report_SwarmingReport* mutable_swarm_report();
  inline ::PRIME::Report_SwarmingReport* release_swarm_report();
  inline void set_allocated_swarm_report(::PRIME::Report_SwarmingReport* swarm_report);

  // optional .PRIME.Report.AddDiffParentReport add_diff_parent_report = 23;
  inline bool has_add_diff_parent_report() const;
  inline void clear_add_diff_parent_report();
  static const int kAddDiffParentReportFieldNumber = 23;
  inline const ::PRIME::Report_AddDiffParentReport& add_diff_parent_report() const;
  inline ::PRIME::Report_AddDiffParentReport* mutable_add_diff_parent_report();
  inline ::PRIME::Report_AddDiffParentReport* release_add_diff_parent_report();
  inline void set_allocated_add_diff_parent_report(::PRIME::Report_AddDiffParentReport* add_diff_parent_report);

  // optional .PRIME.Report.AddSwarmParentReport add_swarm_parent_report = 24;
  inline bool has_add_swarm_parent_report() const;
  inline void clear_add_swarm_parent_report();
  static const int kAddSwarmParentReportFieldNumber = 24;
  inline const ::PRIME::Report_AddSwarmParentReport& add_swarm_parent_report() const;
  inline ::PRIME::Report_AddSwarmParentReport* mutable_add_swarm_parent_report();
  inline ::PRIME::Report_AddSwarmParentReport* release_add_swarm_parent_report();
  inline void set_allocated_add_swarm_parent_report(::PRIME::Report_AddSwarmParentReport* add_swarm_parent_report);

  // optional .PRIME.Report.AddSwarmChildReport add_swarm_child_report = 25;
  inline bool has_add_swarm_child_report() const;
  inline void clear_add_swarm_child_report();
  static const int kAddSwarmChildReportFieldNumber = 25;
  inline const ::PRIME::Report_AddSwarmChildReport& add_swarm_child_report() const;
  inline ::PRIME::Report_AddSwarmChildReport* mutable_add_swarm_child_report();
  inline ::PRIME::Report_AddSwarmChildReport* release_add_swarm_child_report();
  inline void set_allocated_add_swarm_child_report(::PRIME::Report_AddSwarmChildReport* add_swarm_child_report);

  // @@protoc_insertion_point(class_scope:PRIME.Report)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_diff_report();
  inline void clear_has_diff_report();
  inline void set_has_swarm_report();
  inline void clear_has_swarm_report();
  inline void set_has_add_diff_parent_report();
  inline void clear_has_add_diff_parent_report();
  inline void set_has_add_swarm_parent_report();
  inline void clear_has_add_swarm_parent_report();
  inline void set_has_add_swarm_child_report();
  inline void clear_has_add_swarm_child_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PRIME::Report_DiffusionReport* diff_report_;
  ::PRIME::Report_SwarmingReport* swarm_report_;
  ::PRIME::Report_AddDiffParentReport* add_diff_parent_report_;
  ::PRIME::Report_AddSwarmParentReport* add_swarm_parent_report_;
  ::PRIME::Report_AddSwarmChildReport* add_swarm_child_report_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_PRIME_2eproto();
  friend void protobuf_AssignDesc_PRIME_2eproto();
  friend void protobuf_ShutdownFile_PRIME_2eproto();

  void InitAsDefaultInstance();
  static Report* default_instance_;
};
// ===================================================================


// ===================================================================

// PRIMEMessage

// required .PRIME.PRIMEMessage.MsgType type = 1;
inline bool PRIMEMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PRIMEMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PRIMEMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PRIMEMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PRIME::PRIMEMessage_MsgType PRIMEMessage::type() const {
  return static_cast< ::PRIME::PRIMEMessage_MsgType >(type_);
}
inline void PRIMEMessage::set_type(::PRIME::PRIMEMessage_MsgType value) {
  assert(::PRIME::PRIMEMessage_MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .PRIME.Reply reply = 2;
inline bool PRIMEMessage::has_reply() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PRIMEMessage::set_has_reply() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PRIMEMessage::clear_has_reply() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PRIMEMessage::clear_reply() {
  if (reply_ != NULL) reply_->::PRIME::Reply::Clear();
  clear_has_reply();
}
inline const ::PRIME::Reply& PRIMEMessage::reply() const {
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::PRIME::Reply* PRIMEMessage::mutable_reply() {
  set_has_reply();
  if (reply_ == NULL) reply_ = new ::PRIME::Reply;
  return reply_;
}
inline ::PRIME::Reply* PRIMEMessage::release_reply() {
  clear_has_reply();
  ::PRIME::Reply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void PRIMEMessage::set_allocated_reply(::PRIME::Reply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    set_has_reply();
  } else {
    clear_has_reply();
  }
}

// optional .PRIME.Request request = 3;
inline bool PRIMEMessage::has_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PRIMEMessage::set_has_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PRIMEMessage::clear_has_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PRIMEMessage::clear_request() {
  if (request_ != NULL) request_->::PRIME::Request::Clear();
  clear_has_request();
}
inline const ::PRIME::Request& PRIMEMessage::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::PRIME::Request* PRIMEMessage::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::PRIME::Request;
  return request_;
}
inline ::PRIME::Request* PRIMEMessage::release_request() {
  clear_has_request();
  ::PRIME::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void PRIMEMessage::set_allocated_request(::PRIME::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .PRIME.Report report = 4;
inline bool PRIMEMessage::has_report() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PRIMEMessage::set_has_report() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PRIMEMessage::clear_has_report() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PRIMEMessage::clear_report() {
  if (report_ != NULL) report_->::PRIME::Report::Clear();
  clear_has_report();
}
inline const ::PRIME::Report& PRIMEMessage::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::PRIME::Report* PRIMEMessage::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::PRIME::Report;
  return report_;
}
inline ::PRIME::Report* PRIMEMessage::release_report() {
  clear_has_report();
  ::PRIME::Report* temp = report_;
  report_ = NULL;
  return temp;
}
inline void PRIMEMessage::set_allocated_report(::PRIME::Report* report) {
  delete report_;
  report_ = report;
  if (report) {
    set_has_report();
  } else {
    clear_has_report();
  }
}

// optional string dummy = 5;
inline bool PRIMEMessage::has_dummy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PRIMEMessage::set_has_dummy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PRIMEMessage::clear_has_dummy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PRIMEMessage::clear_dummy() {
  if (dummy_ != &::google::protobuf::internal::kEmptyString) {
    dummy_->clear();
  }
  clear_has_dummy();
}
inline const ::std::string& PRIMEMessage::dummy() const {
  return *dummy_;
}
inline void PRIMEMessage::set_dummy(const ::std::string& value) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::kEmptyString) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(value);
}
inline void PRIMEMessage::set_dummy(const char* value) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::kEmptyString) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(value);
}
inline void PRIMEMessage::set_dummy(const char* value, size_t size) {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::kEmptyString) {
    dummy_ = new ::std::string;
  }
  dummy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PRIMEMessage::mutable_dummy() {
  set_has_dummy();
  if (dummy_ == &::google::protobuf::internal::kEmptyString) {
    dummy_ = new ::std::string;
  }
  return dummy_;
}
inline ::std::string* PRIMEMessage::release_dummy() {
  clear_has_dummy();
  if (dummy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dummy_;
    dummy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PRIMEMessage::set_allocated_dummy(::std::string* dummy) {
  if (dummy_ != &::google::protobuf::internal::kEmptyString) {
    delete dummy_;
  }
  if (dummy) {
    set_has_dummy();
    dummy_ = dummy;
  } else {
    clear_has_dummy();
    dummy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PeerInfo

// required string ipAddr = 1;
inline bool PeerInfo::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerInfo::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerInfo::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerInfo::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& PeerInfo::ipaddr() const {
  return *ipaddr_;
}
inline void PeerInfo::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void PeerInfo::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void PeerInfo::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PeerInfo::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* PeerInfo::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PeerInfo::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 repPort = 2;
inline bool PeerInfo::has_repport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerInfo::set_has_repport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerInfo::clear_has_repport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerInfo::clear_repport() {
  repport_ = 0;
  clear_has_repport();
}
inline ::google::protobuf::int32 PeerInfo::repport() const {
  return repport_;
}
inline void PeerInfo::set_repport(::google::protobuf::int32 value) {
  set_has_repport();
  repport_ = value;
}

// required int32 rtpPort = 3;
inline bool PeerInfo::has_rtpport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeerInfo::set_has_rtpport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeerInfo::clear_has_rtpport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeerInfo::clear_rtpport() {
  rtpport_ = 0;
  clear_has_rtpport();
}
inline ::google::protobuf::int32 PeerInfo::rtpport() const {
  return rtpport_;
}
inline void PeerInfo::set_rtpport(::google::protobuf::int32 value) {
  set_has_rtpport();
  rtpport_ = value;
}

// -------------------------------------------------------------------

// Reply_CSSIReply

// required int32 streamPort = 1;
inline bool Reply_CSSIReply::has_streamport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply_CSSIReply::set_has_streamport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply_CSSIReply::clear_has_streamport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply_CSSIReply::clear_streamport() {
  streamport_ = 0;
  clear_has_streamport();
}
inline ::google::protobuf::int32 Reply_CSSIReply::streamport() const {
  return streamport_;
}
inline void Reply_CSSIReply::set_streamport(::google::protobuf::int32 value) {
  set_has_streamport();
  streamport_ = value;
}

// required string sdp = 2;
inline bool Reply_CSSIReply::has_sdp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply_CSSIReply::set_has_sdp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply_CSSIReply::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply_CSSIReply::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& Reply_CSSIReply::sdp() const {
  return *sdp_;
}
inline void Reply_CSSIReply::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void Reply_CSSIReply::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void Reply_CSSIReply::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply_CSSIReply::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* Reply_CSSIReply::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply_CSSIReply::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 maxFrameCount = 3;
inline bool Reply_CSSIReply::has_maxframecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply_CSSIReply::set_has_maxframecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply_CSSIReply::clear_has_maxframecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply_CSSIReply::clear_maxframecount() {
  maxframecount_ = 0;
  clear_has_maxframecount();
}
inline ::google::protobuf::int32 Reply_CSSIReply::maxframecount() const {
  return maxframecount_;
}
inline void Reply_CSSIReply::set_maxframecount(::google::protobuf::int32 value) {
  set_has_maxframecount();
  maxframecount_ = value;
}

// required int32 width = 4;
inline bool Reply_CSSIReply::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply_CSSIReply::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply_CSSIReply::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply_CSSIReply::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Reply_CSSIReply::width() const {
  return width_;
}
inline void Reply_CSSIReply::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 5;
inline bool Reply_CSSIReply::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply_CSSIReply::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply_CSSIReply::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply_CSSIReply::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Reply_CSSIReply::height() const {
  return height_;
}
inline void Reply_CSSIReply::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required int32 pixFmt = 6;
inline bool Reply_CSSIReply::has_pixfmt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply_CSSIReply::set_has_pixfmt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply_CSSIReply::clear_has_pixfmt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply_CSSIReply::clear_pixfmt() {
  pixfmt_ = 0;
  clear_has_pixfmt();
}
inline ::google::protobuf::int32 Reply_CSSIReply::pixfmt() const {
  return pixfmt_;
}
inline void Reply_CSSIReply::set_pixfmt(::google::protobuf::int32 value) {
  set_has_pixfmt();
  pixfmt_ = value;
}

// required .PRIME.PeerInfo diffParent = 7;
inline bool Reply_CSSIReply::has_diffparent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply_CSSIReply::set_has_diffparent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply_CSSIReply::clear_has_diffparent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply_CSSIReply::clear_diffparent() {
  if (diffparent_ != NULL) diffparent_->::PRIME::PeerInfo::Clear();
  clear_has_diffparent();
}
inline const ::PRIME::PeerInfo& Reply_CSSIReply::diffparent() const {
  return diffparent_ != NULL ? *diffparent_ : *default_instance_->diffparent_;
}
inline ::PRIME::PeerInfo* Reply_CSSIReply::mutable_diffparent() {
  set_has_diffparent();
  if (diffparent_ == NULL) diffparent_ = new ::PRIME::PeerInfo;
  return diffparent_;
}
inline ::PRIME::PeerInfo* Reply_CSSIReply::release_diffparent() {
  clear_has_diffparent();
  ::PRIME::PeerInfo* temp = diffparent_;
  diffparent_ = NULL;
  return temp;
}
inline void Reply_CSSIReply::set_allocated_diffparent(::PRIME::PeerInfo* diffparent) {
  delete diffparent_;
  diffparent_ = diffparent;
  if (diffparent) {
    set_has_diffparent();
  } else {
    clear_has_diffparent();
  }
}

// -------------------------------------------------------------------

// Reply_PeerState

// required .PRIME.PeerInfo dest = 1;
inline bool Reply_PeerState::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply_PeerState::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply_PeerState::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply_PeerState::clear_dest() {
  if (dest_ != NULL) dest_->::PRIME::PeerInfo::Clear();
  clear_has_dest();
}
inline const ::PRIME::PeerInfo& Reply_PeerState::dest() const {
  return dest_ != NULL ? *dest_ : *default_instance_->dest_;
}
inline ::PRIME::PeerInfo* Reply_PeerState::mutable_dest() {
  set_has_dest();
  if (dest_ == NULL) dest_ = new ::PRIME::PeerInfo;
  return dest_;
}
inline ::PRIME::PeerInfo* Reply_PeerState::release_dest() {
  clear_has_dest();
  ::PRIME::PeerInfo* temp = dest_;
  dest_ = NULL;
  return temp;
}
inline void Reply_PeerState::set_allocated_dest(::PRIME::PeerInfo* dest) {
  delete dest_;
  dest_ = dest;
  if (dest) {
    set_has_dest();
  } else {
    clear_has_dest();
  }
}

// repeated .PRIME.PeerInfo diffParents = 2;
inline int Reply_PeerState::diffparents_size() const {
  return diffparents_.size();
}
inline void Reply_PeerState::clear_diffparents() {
  diffparents_.Clear();
}
inline const ::PRIME::PeerInfo& Reply_PeerState::diffparents(int index) const {
  return diffparents_.Get(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::mutable_diffparents(int index) {
  return diffparents_.Mutable(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::add_diffparents() {
  return diffparents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
Reply_PeerState::diffparents() const {
  return diffparents_;
}
inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
Reply_PeerState::mutable_diffparents() {
  return &diffparents_;
}

// repeated .PRIME.PeerInfo diffChildren = 3;
inline int Reply_PeerState::diffchildren_size() const {
  return diffchildren_.size();
}
inline void Reply_PeerState::clear_diffchildren() {
  diffchildren_.Clear();
}
inline const ::PRIME::PeerInfo& Reply_PeerState::diffchildren(int index) const {
  return diffchildren_.Get(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::mutable_diffchildren(int index) {
  return diffchildren_.Mutable(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::add_diffchildren() {
  return diffchildren_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
Reply_PeerState::diffchildren() const {
  return diffchildren_;
}
inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
Reply_PeerState::mutable_diffchildren() {
  return &diffchildren_;
}

// repeated .PRIME.PeerInfo swarmParents = 4;
inline int Reply_PeerState::swarmparents_size() const {
  return swarmparents_.size();
}
inline void Reply_PeerState::clear_swarmparents() {
  swarmparents_.Clear();
}
inline const ::PRIME::PeerInfo& Reply_PeerState::swarmparents(int index) const {
  return swarmparents_.Get(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::mutable_swarmparents(int index) {
  return swarmparents_.Mutable(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::add_swarmparents() {
  return swarmparents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
Reply_PeerState::swarmparents() const {
  return swarmparents_;
}
inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
Reply_PeerState::mutable_swarmparents() {
  return &swarmparents_;
}

// repeated .PRIME.PeerInfo swarmChildren = 5;
inline int Reply_PeerState::swarmchildren_size() const {
  return swarmchildren_.size();
}
inline void Reply_PeerState::clear_swarmchildren() {
  swarmchildren_.Clear();
}
inline const ::PRIME::PeerInfo& Reply_PeerState::swarmchildren(int index) const {
  return swarmchildren_.Get(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::mutable_swarmchildren(int index) {
  return swarmchildren_.Mutable(index);
}
inline ::PRIME::PeerInfo* Reply_PeerState::add_swarmchildren() {
  return swarmchildren_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >&
Reply_PeerState::swarmchildren() const {
  return swarmchildren_;
}
inline ::google::protobuf::RepeatedPtrField< ::PRIME::PeerInfo >*
Reply_PeerState::mutable_swarmchildren() {
  return &swarmchildren_;
}

// -------------------------------------------------------------------

// Reply_PRIMEState

// repeated .PRIME.Reply.PeerState nodes = 1;
inline int Reply_PRIMEState::nodes_size() const {
  return nodes_.size();
}
inline void Reply_PRIMEState::clear_nodes() {
  nodes_.Clear();
}
inline const ::PRIME::Reply_PeerState& Reply_PRIMEState::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::PRIME::Reply_PeerState* Reply_PRIMEState::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::PRIME::Reply_PeerState* Reply_PRIMEState::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PRIME::Reply_PeerState >&
Reply_PRIMEState::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::PRIME::Reply_PeerState >*
Reply_PRIMEState::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// Reply_P2PSIReply

// required int32 streamPort = 1;
inline bool Reply_P2PSIReply::has_streamport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply_P2PSIReply::set_has_streamport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply_P2PSIReply::clear_has_streamport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply_P2PSIReply::clear_streamport() {
  streamport_ = 0;
  clear_has_streamport();
}
inline ::google::protobuf::int32 Reply_P2PSIReply::streamport() const {
  return streamport_;
}
inline void Reply_P2PSIReply::set_streamport(::google::protobuf::int32 value) {
  set_has_streamport();
  streamport_ = value;
}

// required string sdp = 2;
inline bool Reply_P2PSIReply::has_sdp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply_P2PSIReply::set_has_sdp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply_P2PSIReply::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply_P2PSIReply::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& Reply_P2PSIReply::sdp() const {
  return *sdp_;
}
inline void Reply_P2PSIReply::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void Reply_P2PSIReply::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void Reply_P2PSIReply::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply_P2PSIReply::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* Reply_P2PSIReply::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply_P2PSIReply::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 maxFrameCount = 3;
inline bool Reply_P2PSIReply::has_maxframecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply_P2PSIReply::set_has_maxframecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply_P2PSIReply::clear_has_maxframecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply_P2PSIReply::clear_maxframecount() {
  maxframecount_ = 0;
  clear_has_maxframecount();
}
inline ::google::protobuf::int32 Reply_P2PSIReply::maxframecount() const {
  return maxframecount_;
}
inline void Reply_P2PSIReply::set_maxframecount(::google::protobuf::int32 value) {
  set_has_maxframecount();
  maxframecount_ = value;
}

// required int32 width = 4;
inline bool Reply_P2PSIReply::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply_P2PSIReply::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply_P2PSIReply::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply_P2PSIReply::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Reply_P2PSIReply::width() const {
  return width_;
}
inline void Reply_P2PSIReply::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 5;
inline bool Reply_P2PSIReply::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply_P2PSIReply::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply_P2PSIReply::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply_P2PSIReply::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Reply_P2PSIReply::height() const {
  return height_;
}
inline void Reply_P2PSIReply::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required int32 pixFmt = 6;
inline bool Reply_P2PSIReply::has_pixfmt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply_P2PSIReply::set_has_pixfmt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply_P2PSIReply::clear_has_pixfmt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply_P2PSIReply::clear_pixfmt() {
  pixfmt_ = 0;
  clear_has_pixfmt();
}
inline ::google::protobuf::int32 Reply_P2PSIReply::pixfmt() const {
  return pixfmt_;
}
inline void Reply_P2PSIReply::set_pixfmt(::google::protobuf::int32 value) {
  set_has_pixfmt();
  pixfmt_ = value;
}

// required .PRIME.PeerInfo diffParent = 7;
inline bool Reply_P2PSIReply::has_diffparent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply_P2PSIReply::set_has_diffparent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply_P2PSIReply::clear_has_diffparent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply_P2PSIReply::clear_diffparent() {
  if (diffparent_ != NULL) diffparent_->::PRIME::PeerInfo::Clear();
  clear_has_diffparent();
}
inline const ::PRIME::PeerInfo& Reply_P2PSIReply::diffparent() const {
  return diffparent_ != NULL ? *diffparent_ : *default_instance_->diffparent_;
}
inline ::PRIME::PeerInfo* Reply_P2PSIReply::mutable_diffparent() {
  set_has_diffparent();
  if (diffparent_ == NULL) diffparent_ = new ::PRIME::PeerInfo;
  return diffparent_;
}
inline ::PRIME::PeerInfo* Reply_P2PSIReply::release_diffparent() {
  clear_has_diffparent();
  ::PRIME::PeerInfo* temp = diffparent_;
  diffparent_ = NULL;
  return temp;
}
inline void Reply_P2PSIReply::set_allocated_diffparent(::PRIME::PeerInfo* diffparent) {
  delete diffparent_;
  diffparent_ = diffparent;
  if (diffparent) {
    set_has_diffparent();
  } else {
    clear_has_diffparent();
  }
}

// -------------------------------------------------------------------

// Reply

// required .PRIME.Reply.ReplyType Type = 1;
inline bool Reply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PRIME::Reply_ReplyType Reply::type() const {
  return static_cast< ::PRIME::Reply_ReplyType >(type_);
}
inline void Reply::set_type(::PRIME::Reply_ReplyType value) {
  assert(::PRIME::Reply_ReplyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .PRIME.Reply.CSSIReply cs_session_state = 21;
inline bool Reply::has_cs_session_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_cs_session_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_cs_session_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_cs_session_state() {
  if (cs_session_state_ != NULL) cs_session_state_->::PRIME::Reply_CSSIReply::Clear();
  clear_has_cs_session_state();
}
inline const ::PRIME::Reply_CSSIReply& Reply::cs_session_state() const {
  return cs_session_state_ != NULL ? *cs_session_state_ : *default_instance_->cs_session_state_;
}
inline ::PRIME::Reply_CSSIReply* Reply::mutable_cs_session_state() {
  set_has_cs_session_state();
  if (cs_session_state_ == NULL) cs_session_state_ = new ::PRIME::Reply_CSSIReply;
  return cs_session_state_;
}
inline ::PRIME::Reply_CSSIReply* Reply::release_cs_session_state() {
  clear_has_cs_session_state();
  ::PRIME::Reply_CSSIReply* temp = cs_session_state_;
  cs_session_state_ = NULL;
  return temp;
}
inline void Reply::set_allocated_cs_session_state(::PRIME::Reply_CSSIReply* cs_session_state) {
  delete cs_session_state_;
  cs_session_state_ = cs_session_state;
  if (cs_session_state) {
    set_has_cs_session_state();
  } else {
    clear_has_cs_session_state();
  }
}

// optional .PRIME.Reply.P2PSIReply p2p_session_state = 22;
inline bool Reply::has_p2p_session_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_p2p_session_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_p2p_session_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_p2p_session_state() {
  if (p2p_session_state_ != NULL) p2p_session_state_->::PRIME::Reply_P2PSIReply::Clear();
  clear_has_p2p_session_state();
}
inline const ::PRIME::Reply_P2PSIReply& Reply::p2p_session_state() const {
  return p2p_session_state_ != NULL ? *p2p_session_state_ : *default_instance_->p2p_session_state_;
}
inline ::PRIME::Reply_P2PSIReply* Reply::mutable_p2p_session_state() {
  set_has_p2p_session_state();
  if (p2p_session_state_ == NULL) p2p_session_state_ = new ::PRIME::Reply_P2PSIReply;
  return p2p_session_state_;
}
inline ::PRIME::Reply_P2PSIReply* Reply::release_p2p_session_state() {
  clear_has_p2p_session_state();
  ::PRIME::Reply_P2PSIReply* temp = p2p_session_state_;
  p2p_session_state_ = NULL;
  return temp;
}
inline void Reply::set_allocated_p2p_session_state(::PRIME::Reply_P2PSIReply* p2p_session_state) {
  delete p2p_session_state_;
  p2p_session_state_ = p2p_session_state;
  if (p2p_session_state) {
    set_has_p2p_session_state();
  } else {
    clear_has_p2p_session_state();
  }
}

// -------------------------------------------------------------------

// Request_CSSIRequest

// required double DBW = 1;
inline bool Request_CSSIRequest::has_dbw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_CSSIRequest::set_has_dbw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_CSSIRequest::clear_has_dbw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_CSSIRequest::clear_dbw() {
  dbw_ = 0;
  clear_has_dbw();
}
inline double Request_CSSIRequest::dbw() const {
  return dbw_;
}
inline void Request_CSSIRequest::set_dbw(double value) {
  set_has_dbw();
  dbw_ = value;
}

// required string peerName = 2;
inline bool Request_CSSIRequest::has_peername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_CSSIRequest::set_has_peername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_CSSIRequest::clear_has_peername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_CSSIRequest::clear_peername() {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    peername_->clear();
  }
  clear_has_peername();
}
inline const ::std::string& Request_CSSIRequest::peername() const {
  return *peername_;
}
inline void Request_CSSIRequest::set_peername(const ::std::string& value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Request_CSSIRequest::set_peername(const char* value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Request_CSSIRequest::set_peername(const char* value, size_t size) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_CSSIRequest::mutable_peername() {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  return peername_;
}
inline ::std::string* Request_CSSIRequest::release_peername() {
  clear_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peername_;
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_CSSIRequest::set_allocated_peername(::std::string* peername) {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    delete peername_;
  }
  if (peername) {
    set_has_peername();
    peername_ = peername;
  } else {
    clear_has_peername();
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 repPort = 3;
inline bool Request_CSSIRequest::has_repport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_CSSIRequest::set_has_repport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_CSSIRequest::clear_has_repport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_CSSIRequest::clear_repport() {
  repport_ = 0;
  clear_has_repport();
}
inline ::google::protobuf::int32 Request_CSSIRequest::repport() const {
  return repport_;
}
inline void Request_CSSIRequest::set_repport(::google::protobuf::int32 value) {
  set_has_repport();
  repport_ = value;
}

// required string ipAddr = 4;
inline bool Request_CSSIRequest::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_CSSIRequest::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_CSSIRequest::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_CSSIRequest::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& Request_CSSIRequest::ipaddr() const {
  return *ipaddr_;
}
inline void Request_CSSIRequest::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void Request_CSSIRequest::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void Request_CSSIRequest::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_CSSIRequest::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* Request_CSSIRequest::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_CSSIRequest::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request_P2PSIRequest

// required double DBW = 1;
inline bool Request_P2PSIRequest::has_dbw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_P2PSIRequest::set_has_dbw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_P2PSIRequest::clear_has_dbw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_P2PSIRequest::clear_dbw() {
  dbw_ = 0;
  clear_has_dbw();
}
inline double Request_P2PSIRequest::dbw() const {
  return dbw_;
}
inline void Request_P2PSIRequest::set_dbw(double value) {
  set_has_dbw();
  dbw_ = value;
}

// required double UBW = 2;
inline bool Request_P2PSIRequest::has_ubw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_P2PSIRequest::set_has_ubw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_P2PSIRequest::clear_has_ubw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_P2PSIRequest::clear_ubw() {
  ubw_ = 0;
  clear_has_ubw();
}
inline double Request_P2PSIRequest::ubw() const {
  return ubw_;
}
inline void Request_P2PSIRequest::set_ubw(double value) {
  set_has_ubw();
  ubw_ = value;
}

// required int32 repPort = 3;
inline bool Request_P2PSIRequest::has_repport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request_P2PSIRequest::set_has_repport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request_P2PSIRequest::clear_has_repport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request_P2PSIRequest::clear_repport() {
  repport_ = 0;
  clear_has_repport();
}
inline ::google::protobuf::int32 Request_P2PSIRequest::repport() const {
  return repport_;
}
inline void Request_P2PSIRequest::set_repport(::google::protobuf::int32 value) {
  set_has_repport();
  repport_ = value;
}

// required int32 rtpRecvPort = 4;
inline bool Request_P2PSIRequest::has_rtprecvport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_P2PSIRequest::set_has_rtprecvport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_P2PSIRequest::clear_has_rtprecvport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_P2PSIRequest::clear_rtprecvport() {
  rtprecvport_ = 0;
  clear_has_rtprecvport();
}
inline ::google::protobuf::int32 Request_P2PSIRequest::rtprecvport() const {
  return rtprecvport_;
}
inline void Request_P2PSIRequest::set_rtprecvport(::google::protobuf::int32 value) {
  set_has_rtprecvport();
  rtprecvport_ = value;
}

// required int32 repSendPort = 5;
inline bool Request_P2PSIRequest::has_repsendport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_P2PSIRequest::set_has_repsendport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_P2PSIRequest::clear_has_repsendport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_P2PSIRequest::clear_repsendport() {
  repsendport_ = 0;
  clear_has_repsendport();
}
inline ::google::protobuf::int32 Request_P2PSIRequest::repsendport() const {
  return repsendport_;
}
inline void Request_P2PSIRequest::set_repsendport(::google::protobuf::int32 value) {
  set_has_repsendport();
  repsendport_ = value;
}

// required string peerName = 6;
inline bool Request_P2PSIRequest::has_peername() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_P2PSIRequest::set_has_peername() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_P2PSIRequest::clear_has_peername() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_P2PSIRequest::clear_peername() {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    peername_->clear();
  }
  clear_has_peername();
}
inline const ::std::string& Request_P2PSIRequest::peername() const {
  return *peername_;
}
inline void Request_P2PSIRequest::set_peername(const ::std::string& value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Request_P2PSIRequest::set_peername(const char* value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Request_P2PSIRequest::set_peername(const char* value, size_t size) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_P2PSIRequest::mutable_peername() {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  return peername_;
}
inline ::std::string* Request_P2PSIRequest::release_peername() {
  clear_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peername_;
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_P2PSIRequest::set_allocated_peername(::std::string* peername) {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    delete peername_;
  }
  if (peername) {
    set_has_peername();
    peername_ = peername;
  } else {
    clear_has_peername();
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ipAddr = 7;
inline bool Request_P2PSIRequest::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request_P2PSIRequest::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request_P2PSIRequest::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request_P2PSIRequest::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& Request_P2PSIRequest::ipaddr() const {
  return *ipaddr_;
}
inline void Request_P2PSIRequest::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void Request_P2PSIRequest::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void Request_P2PSIRequest::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request_P2PSIRequest::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* Request_P2PSIRequest::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request_P2PSIRequest::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request

// required .PRIME.Request.RequestType Type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PRIME::Request_RequestType Request::type() const {
  return static_cast< ::PRIME::Request_RequestType >(type_);
}
inline void Request::set_type(::PRIME::Request_RequestType value) {
  assert(::PRIME::Request_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .PRIME.Request.CSSIRequest cs_session_props = 21;
inline bool Request::has_cs_session_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_cs_session_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_cs_session_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_cs_session_props() {
  if (cs_session_props_ != NULL) cs_session_props_->::PRIME::Request_CSSIRequest::Clear();
  clear_has_cs_session_props();
}
inline const ::PRIME::Request_CSSIRequest& Request::cs_session_props() const {
  return cs_session_props_ != NULL ? *cs_session_props_ : *default_instance_->cs_session_props_;
}
inline ::PRIME::Request_CSSIRequest* Request::mutable_cs_session_props() {
  set_has_cs_session_props();
  if (cs_session_props_ == NULL) cs_session_props_ = new ::PRIME::Request_CSSIRequest;
  return cs_session_props_;
}
inline ::PRIME::Request_CSSIRequest* Request::release_cs_session_props() {
  clear_has_cs_session_props();
  ::PRIME::Request_CSSIRequest* temp = cs_session_props_;
  cs_session_props_ = NULL;
  return temp;
}
inline void Request::set_allocated_cs_session_props(::PRIME::Request_CSSIRequest* cs_session_props) {
  delete cs_session_props_;
  cs_session_props_ = cs_session_props;
  if (cs_session_props) {
    set_has_cs_session_props();
  } else {
    clear_has_cs_session_props();
  }
}

// optional .PRIME.Request.P2PSIRequest p2p_session_props = 22;
inline bool Request::has_p2p_session_props() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_p2p_session_props() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_p2p_session_props() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_p2p_session_props() {
  if (p2p_session_props_ != NULL) p2p_session_props_->::PRIME::Request_P2PSIRequest::Clear();
  clear_has_p2p_session_props();
}
inline const ::PRIME::Request_P2PSIRequest& Request::p2p_session_props() const {
  return p2p_session_props_ != NULL ? *p2p_session_props_ : *default_instance_->p2p_session_props_;
}
inline ::PRIME::Request_P2PSIRequest* Request::mutable_p2p_session_props() {
  set_has_p2p_session_props();
  if (p2p_session_props_ == NULL) p2p_session_props_ = new ::PRIME::Request_P2PSIRequest;
  return p2p_session_props_;
}
inline ::PRIME::Request_P2PSIRequest* Request::release_p2p_session_props() {
  clear_has_p2p_session_props();
  ::PRIME::Request_P2PSIRequest* temp = p2p_session_props_;
  p2p_session_props_ = NULL;
  return temp;
}
inline void Request::set_allocated_p2p_session_props(::PRIME::Request_P2PSIRequest* p2p_session_props) {
  delete p2p_session_props_;
  p2p_session_props_ = p2p_session_props;
  if (p2p_session_props) {
    set_has_p2p_session_props();
  } else {
    clear_has_p2p_session_props();
  }
}

// -------------------------------------------------------------------

// Report_DiffusionReport

// required uint64 start_ts = 1;
inline bool Report_DiffusionReport::has_start_ts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_DiffusionReport::set_has_start_ts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report_DiffusionReport::clear_has_start_ts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report_DiffusionReport::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
  clear_has_start_ts();
}
inline ::google::protobuf::uint64 Report_DiffusionReport::start_ts() const {
  return start_ts_;
}
inline void Report_DiffusionReport::set_start_ts(::google::protobuf::uint64 value) {
  set_has_start_ts();
  start_ts_ = value;
}

// required uint64 end_ts = 2;
inline bool Report_DiffusionReport::has_end_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report_DiffusionReport::set_has_end_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Report_DiffusionReport::clear_has_end_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Report_DiffusionReport::clear_end_ts() {
  end_ts_ = GOOGLE_ULONGLONG(0);
  clear_has_end_ts();
}
inline ::google::protobuf::uint64 Report_DiffusionReport::end_ts() const {
  return end_ts_;
}
inline void Report_DiffusionReport::set_end_ts(::google::protobuf::uint64 value) {
  set_has_end_ts();
  end_ts_ = value;
}

// required uint32 start_seq = 3;
inline bool Report_DiffusionReport::has_start_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Report_DiffusionReport::set_has_start_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Report_DiffusionReport::clear_has_start_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Report_DiffusionReport::clear_start_seq() {
  start_seq_ = 0u;
  clear_has_start_seq();
}
inline ::google::protobuf::uint32 Report_DiffusionReport::start_seq() const {
  return start_seq_;
}
inline void Report_DiffusionReport::set_start_seq(::google::protobuf::uint32 value) {
  set_has_start_seq();
  start_seq_ = value;
}

// required uint32 end_seq = 4;
inline bool Report_DiffusionReport::has_end_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Report_DiffusionReport::set_has_end_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Report_DiffusionReport::clear_has_end_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Report_DiffusionReport::clear_end_seq() {
  end_seq_ = 0u;
  clear_has_end_seq();
}
inline ::google::protobuf::uint32 Report_DiffusionReport::end_seq() const {
  return end_seq_;
}
inline void Report_DiffusionReport::set_end_seq(::google::protobuf::uint32 value) {
  set_has_end_seq();
  end_seq_ = value;
}

// -------------------------------------------------------------------

// Report_SwarmingReport

// required uint32 start_seq = 1;
inline bool Report_SwarmingReport::has_start_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_SwarmingReport::set_has_start_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report_SwarmingReport::clear_has_start_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report_SwarmingReport::clear_start_seq() {
  start_seq_ = 0u;
  clear_has_start_seq();
}
inline ::google::protobuf::uint32 Report_SwarmingReport::start_seq() const {
  return start_seq_;
}
inline void Report_SwarmingReport::set_start_seq(::google::protobuf::uint32 value) {
  set_has_start_seq();
  start_seq_ = value;
}

// required uint32 end_seq = 2;
inline bool Report_SwarmingReport::has_end_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report_SwarmingReport::set_has_end_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Report_SwarmingReport::clear_has_end_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Report_SwarmingReport::clear_end_seq() {
  end_seq_ = 0u;
  clear_has_end_seq();
}
inline ::google::protobuf::uint32 Report_SwarmingReport::end_seq() const {
  return end_seq_;
}
inline void Report_SwarmingReport::set_end_seq(::google::protobuf::uint32 value) {
  set_has_end_seq();
  end_seq_ = value;
}

// repeated bool state = 3;
inline int Report_SwarmingReport::state_size() const {
  return state_.size();
}
inline void Report_SwarmingReport::clear_state() {
  state_.Clear();
}
inline bool Report_SwarmingReport::state(int index) const {
  return state_.Get(index);
}
inline void Report_SwarmingReport::set_state(int index, bool value) {
  state_.Set(index, value);
}
inline void Report_SwarmingReport::add_state(bool value) {
  state_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
Report_SwarmingReport::state() const {
  return state_;
}
inline ::google::protobuf::RepeatedField< bool >*
Report_SwarmingReport::mutable_state() {
  return &state_;
}

// -------------------------------------------------------------------

// Report_AddDiffParentReport

// required string peerName = 1;
inline bool Report_AddDiffParentReport::has_peername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_AddDiffParentReport::set_has_peername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report_AddDiffParentReport::clear_has_peername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report_AddDiffParentReport::clear_peername() {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    peername_->clear();
  }
  clear_has_peername();
}
inline const ::std::string& Report_AddDiffParentReport::peername() const {
  return *peername_;
}
inline void Report_AddDiffParentReport::set_peername(const ::std::string& value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Report_AddDiffParentReport::set_peername(const char* value) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(value);
}
inline void Report_AddDiffParentReport::set_peername(const char* value, size_t size) {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  peername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Report_AddDiffParentReport::mutable_peername() {
  set_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    peername_ = new ::std::string;
  }
  return peername_;
}
inline ::std::string* Report_AddDiffParentReport::release_peername() {
  clear_has_peername();
  if (peername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peername_;
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Report_AddDiffParentReport::set_allocated_peername(::std::string* peername) {
  if (peername_ != &::google::protobuf::internal::kEmptyString) {
    delete peername_;
  }
  if (peername) {
    set_has_peername();
    peername_ = peername;
  } else {
    clear_has_peername();
    peername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 stream_port = 2;
inline bool Report_AddDiffParentReport::has_stream_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report_AddDiffParentReport::set_has_stream_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Report_AddDiffParentReport::clear_has_stream_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Report_AddDiffParentReport::clear_stream_port() {
  stream_port_ = 0;
  clear_has_stream_port();
}
inline ::google::protobuf::int32 Report_AddDiffParentReport::stream_port() const {
  return stream_port_;
}
inline void Report_AddDiffParentReport::set_stream_port(::google::protobuf::int32 value) {
  set_has_stream_port();
  stream_port_ = value;
}

// required int32 rep_port = 3;
inline bool Report_AddDiffParentReport::has_rep_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Report_AddDiffParentReport::set_has_rep_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Report_AddDiffParentReport::clear_has_rep_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Report_AddDiffParentReport::clear_rep_port() {
  rep_port_ = 0;
  clear_has_rep_port();
}
inline ::google::protobuf::int32 Report_AddDiffParentReport::rep_port() const {
  return rep_port_;
}
inline void Report_AddDiffParentReport::set_rep_port(::google::protobuf::int32 value) {
  set_has_rep_port();
  rep_port_ = value;
}

// -------------------------------------------------------------------

// Report_AddSwarmParentReport

// required .PRIME.PeerInfo swarmParent = 1;
inline bool Report_AddSwarmParentReport::has_swarmparent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_AddSwarmParentReport::set_has_swarmparent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report_AddSwarmParentReport::clear_has_swarmparent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report_AddSwarmParentReport::clear_swarmparent() {
  if (swarmparent_ != NULL) swarmparent_->::PRIME::PeerInfo::Clear();
  clear_has_swarmparent();
}
inline const ::PRIME::PeerInfo& Report_AddSwarmParentReport::swarmparent() const {
  return swarmparent_ != NULL ? *swarmparent_ : *default_instance_->swarmparent_;
}
inline ::PRIME::PeerInfo* Report_AddSwarmParentReport::mutable_swarmparent() {
  set_has_swarmparent();
  if (swarmparent_ == NULL) swarmparent_ = new ::PRIME::PeerInfo;
  return swarmparent_;
}
inline ::PRIME::PeerInfo* Report_AddSwarmParentReport::release_swarmparent() {
  clear_has_swarmparent();
  ::PRIME::PeerInfo* temp = swarmparent_;
  swarmparent_ = NULL;
  return temp;
}
inline void Report_AddSwarmParentReport::set_allocated_swarmparent(::PRIME::PeerInfo* swarmparent) {
  delete swarmparent_;
  swarmparent_ = swarmparent;
  if (swarmparent) {
    set_has_swarmparent();
  } else {
    clear_has_swarmparent();
  }
}

// -------------------------------------------------------------------

// Report_AddSwarmChildReport

// required .PRIME.PeerInfo swarmChild = 1;
inline bool Report_AddSwarmChildReport::has_swarmchild() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report_AddSwarmChildReport::set_has_swarmchild() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report_AddSwarmChildReport::clear_has_swarmchild() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report_AddSwarmChildReport::clear_swarmchild() {
  if (swarmchild_ != NULL) swarmchild_->::PRIME::PeerInfo::Clear();
  clear_has_swarmchild();
}
inline const ::PRIME::PeerInfo& Report_AddSwarmChildReport::swarmchild() const {
  return swarmchild_ != NULL ? *swarmchild_ : *default_instance_->swarmchild_;
}
inline ::PRIME::PeerInfo* Report_AddSwarmChildReport::mutable_swarmchild() {
  set_has_swarmchild();
  if (swarmchild_ == NULL) swarmchild_ = new ::PRIME::PeerInfo;
  return swarmchild_;
}
inline ::PRIME::PeerInfo* Report_AddSwarmChildReport::release_swarmchild() {
  clear_has_swarmchild();
  ::PRIME::PeerInfo* temp = swarmchild_;
  swarmchild_ = NULL;
  return temp;
}
inline void Report_AddSwarmChildReport::set_allocated_swarmchild(::PRIME::PeerInfo* swarmchild) {
  delete swarmchild_;
  swarmchild_ = swarmchild;
  if (swarmchild) {
    set_has_swarmchild();
  } else {
    clear_has_swarmchild();
  }
}

// -------------------------------------------------------------------

// Report

// required .PRIME.Report.ReportType Type = 1;
inline bool Report::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Report::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Report::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Report::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PRIME::Report_ReportType Report::type() const {
  return static_cast< ::PRIME::Report_ReportType >(type_);
}
inline void Report::set_type(::PRIME::Report_ReportType value) {
  assert(::PRIME::Report_ReportType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .PRIME.Report.DiffusionReport diff_report = 21;
inline bool Report::has_diff_report() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Report::set_has_diff_report() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Report::clear_has_diff_report() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Report::clear_diff_report() {
  if (diff_report_ != NULL) diff_report_->::PRIME::Report_DiffusionReport::Clear();
  clear_has_diff_report();
}
inline const ::PRIME::Report_DiffusionReport& Report::diff_report() const {
  return diff_report_ != NULL ? *diff_report_ : *default_instance_->diff_report_;
}
inline ::PRIME::Report_DiffusionReport* Report::mutable_diff_report() {
  set_has_diff_report();
  if (diff_report_ == NULL) diff_report_ = new ::PRIME::Report_DiffusionReport;
  return diff_report_;
}
inline ::PRIME::Report_DiffusionReport* Report::release_diff_report() {
  clear_has_diff_report();
  ::PRIME::Report_DiffusionReport* temp = diff_report_;
  diff_report_ = NULL;
  return temp;
}
inline void Report::set_allocated_diff_report(::PRIME::Report_DiffusionReport* diff_report) {
  delete diff_report_;
  diff_report_ = diff_report;
  if (diff_report) {
    set_has_diff_report();
  } else {
    clear_has_diff_report();
  }
}

// optional .PRIME.Report.SwarmingReport swarm_report = 22;
inline bool Report::has_swarm_report() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Report::set_has_swarm_report() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Report::clear_has_swarm_report() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Report::clear_swarm_report() {
  if (swarm_report_ != NULL) swarm_report_->::PRIME::Report_SwarmingReport::Clear();
  clear_has_swarm_report();
}
inline const ::PRIME::Report_SwarmingReport& Report::swarm_report() const {
  return swarm_report_ != NULL ? *swarm_report_ : *default_instance_->swarm_report_;
}
inline ::PRIME::Report_SwarmingReport* Report::mutable_swarm_report() {
  set_has_swarm_report();
  if (swarm_report_ == NULL) swarm_report_ = new ::PRIME::Report_SwarmingReport;
  return swarm_report_;
}
inline ::PRIME::Report_SwarmingReport* Report::release_swarm_report() {
  clear_has_swarm_report();
  ::PRIME::Report_SwarmingReport* temp = swarm_report_;
  swarm_report_ = NULL;
  return temp;
}
inline void Report::set_allocated_swarm_report(::PRIME::Report_SwarmingReport* swarm_report) {
  delete swarm_report_;
  swarm_report_ = swarm_report;
  if (swarm_report) {
    set_has_swarm_report();
  } else {
    clear_has_swarm_report();
  }
}

// optional .PRIME.Report.AddDiffParentReport add_diff_parent_report = 23;
inline bool Report::has_add_diff_parent_report() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Report::set_has_add_diff_parent_report() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Report::clear_has_add_diff_parent_report() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Report::clear_add_diff_parent_report() {
  if (add_diff_parent_report_ != NULL) add_diff_parent_report_->::PRIME::Report_AddDiffParentReport::Clear();
  clear_has_add_diff_parent_report();
}
inline const ::PRIME::Report_AddDiffParentReport& Report::add_diff_parent_report() const {
  return add_diff_parent_report_ != NULL ? *add_diff_parent_report_ : *default_instance_->add_diff_parent_report_;
}
inline ::PRIME::Report_AddDiffParentReport* Report::mutable_add_diff_parent_report() {
  set_has_add_diff_parent_report();
  if (add_diff_parent_report_ == NULL) add_diff_parent_report_ = new ::PRIME::Report_AddDiffParentReport;
  return add_diff_parent_report_;
}
inline ::PRIME::Report_AddDiffParentReport* Report::release_add_diff_parent_report() {
  clear_has_add_diff_parent_report();
  ::PRIME::Report_AddDiffParentReport* temp = add_diff_parent_report_;
  add_diff_parent_report_ = NULL;
  return temp;
}
inline void Report::set_allocated_add_diff_parent_report(::PRIME::Report_AddDiffParentReport* add_diff_parent_report) {
  delete add_diff_parent_report_;
  add_diff_parent_report_ = add_diff_parent_report;
  if (add_diff_parent_report) {
    set_has_add_diff_parent_report();
  } else {
    clear_has_add_diff_parent_report();
  }
}

// optional .PRIME.Report.AddSwarmParentReport add_swarm_parent_report = 24;
inline bool Report::has_add_swarm_parent_report() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Report::set_has_add_swarm_parent_report() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Report::clear_has_add_swarm_parent_report() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Report::clear_add_swarm_parent_report() {
  if (add_swarm_parent_report_ != NULL) add_swarm_parent_report_->::PRIME::Report_AddSwarmParentReport::Clear();
  clear_has_add_swarm_parent_report();
}
inline const ::PRIME::Report_AddSwarmParentReport& Report::add_swarm_parent_report() const {
  return add_swarm_parent_report_ != NULL ? *add_swarm_parent_report_ : *default_instance_->add_swarm_parent_report_;
}
inline ::PRIME::Report_AddSwarmParentReport* Report::mutable_add_swarm_parent_report() {
  set_has_add_swarm_parent_report();
  if (add_swarm_parent_report_ == NULL) add_swarm_parent_report_ = new ::PRIME::Report_AddSwarmParentReport;
  return add_swarm_parent_report_;
}
inline ::PRIME::Report_AddSwarmParentReport* Report::release_add_swarm_parent_report() {
  clear_has_add_swarm_parent_report();
  ::PRIME::Report_AddSwarmParentReport* temp = add_swarm_parent_report_;
  add_swarm_parent_report_ = NULL;
  return temp;
}
inline void Report::set_allocated_add_swarm_parent_report(::PRIME::Report_AddSwarmParentReport* add_swarm_parent_report) {
  delete add_swarm_parent_report_;
  add_swarm_parent_report_ = add_swarm_parent_report;
  if (add_swarm_parent_report) {
    set_has_add_swarm_parent_report();
  } else {
    clear_has_add_swarm_parent_report();
  }
}

// optional .PRIME.Report.AddSwarmChildReport add_swarm_child_report = 25;
inline bool Report::has_add_swarm_child_report() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Report::set_has_add_swarm_child_report() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Report::clear_has_add_swarm_child_report() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Report::clear_add_swarm_child_report() {
  if (add_swarm_child_report_ != NULL) add_swarm_child_report_->::PRIME::Report_AddSwarmChildReport::Clear();
  clear_has_add_swarm_child_report();
}
inline const ::PRIME::Report_AddSwarmChildReport& Report::add_swarm_child_report() const {
  return add_swarm_child_report_ != NULL ? *add_swarm_child_report_ : *default_instance_->add_swarm_child_report_;
}
inline ::PRIME::Report_AddSwarmChildReport* Report::mutable_add_swarm_child_report() {
  set_has_add_swarm_child_report();
  if (add_swarm_child_report_ == NULL) add_swarm_child_report_ = new ::PRIME::Report_AddSwarmChildReport;
  return add_swarm_child_report_;
}
inline ::PRIME::Report_AddSwarmChildReport* Report::release_add_swarm_child_report() {
  clear_has_add_swarm_child_report();
  ::PRIME::Report_AddSwarmChildReport* temp = add_swarm_child_report_;
  add_swarm_child_report_ = NULL;
  return temp;
}
inline void Report::set_allocated_add_swarm_child_report(::PRIME::Report_AddSwarmChildReport* add_swarm_child_report) {
  delete add_swarm_child_report_;
  add_swarm_child_report_ = add_swarm_child_report;
  if (add_swarm_child_report) {
    set_has_add_swarm_child_report();
  } else {
    clear_has_add_swarm_child_report();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PRIME

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRIME::PRIMEMessage_MsgType>() {
  return ::PRIME::PRIMEMessage_MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRIME::Reply_ReplyType>() {
  return ::PRIME::Reply_ReplyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRIME::Request_RequestType>() {
  return ::PRIME::Request_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRIME::Report_ReportType>() {
  return ::PRIME::Report_ReportType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PRIME_2eproto__INCLUDED
